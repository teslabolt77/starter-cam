#!/usr/bin/env python3
import os, cv2, csv, argparse, time
import numpy as np
from datetime import datetime

BASE = os.path.expanduser("~/starter_cam")
LOG_CSV = os.path.join(BASE, "starter_log.csv")

# ROI for your jar (tweak if needed)
# Format: x1,y1,x2,y2 in full-frame pixels
ROI = (430, 95, 930, 680)

# Search band INSIDE ROI to avoid lid reflections:
SEARCH_TOP_FRAC = 0.35   # ignore top 35% of ROI
SEARCH_BOT_FRAC = 0.05   # ignore bottom 5% (table edge, etc.)

# Edge detection tuning
CANNY1, CANNY2 = 35, 110
MIN_EDGE_DENSITY = 0.02   # how “edgy” a row must be to be considered a surface
SMOOTH_K = 9              # median blur kernel

def now_iso():
    return datetime.now().isoformat(timespec="seconds")

def open_camera():
    # C920 often works best with V4L2 backend
    cap = cv2.VideoCapture(0, cv2.CAP_V4L2)
    cap.set(cv2.CAP_PROP_FRAME_WIDTH, 1280)
    cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 720)
    cap.set(cv2.CAP_PROP_FPS, 30)
    # warm up
    for _ in range(8):
        cap.read()
        time.sleep(0.03)
    return cap

def detect_surface_y(roi, top_frac, bot_frac):
    """
    Returns (surface_y, rejected_flag)
    surface_y is in ROI coordinates (0..h-1)
    """
    h, w = roi.shape[:2]
    y0 = int(h * top_frac)
    y1 = int(h * (1.0 - bot_frac))
    if y1 <= y0 + 10:
        return 0, 1

    band = roi[y0:y1, :]

    gray = cv2.cvtColor(band, cv2.COLOR_BGR2GRAY)
    gray = cv2.medianBlur(gray, SMOOTH_K)

    edges = cv2.Canny(gray, CANNY1, CANNY2)

    # row "edge density" (fraction of pixels that are edges)
    row_score = edges.mean(axis=1) / 255.0

    # We want the FIRST strong horizontal edge from top of band
    # because that corresponds to the dough surface boundary.
    idx = np.where(row_score > MIN_EDGE_DENSITY)[0]
    if idx.size == 0:
        # no good surface found
        return y0, 1

    surface_in_band = int(idx[0])
    surface_y = y0 + surface_in_band
    return surface_y, 0

def append_log(ts, height_px, rejected):
    os.makedirs(os.path.dirname(LOG_CSV), exist_ok=True)
    exists = os.path.exists(LOG_CSV)
    with open(LOG_CSV, "a", newline="") as f:
        w = csv.writer(f)
        if not exists:
            w.writerow(["timestamp", "height_px", "rejected"])
        w.writerow([ts, int(height_px), int(rejected)])

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--device", default="0")
    ap.add_argument("--save-image", action="store_true")
    ap.add_argument("--image-dir", default=os.path.join(BASE, "photos_run"))
    ap.add_argument("--prefix", default="run")
    args = ap.parse_args()

    cap = open_camera()
    ok, frame = cap.read()
    cap.release()

    if not ok or frame is None:
        print("Camera read failed.")
        return 2

    x1,y1,x2,y2 = ROI
    x1 = max(0, x1); y1 = max(0, y1)
    x2 = min(frame.shape[1], x2); y2 = min(frame.shape[0], y2)

    roi = frame[y1:y2, x1:x2].copy()
    h_roi = roi.shape[0]

    surface_y, rejected = detect_surface_y(roi, SEARCH_TOP_FRAC, SEARCH_BOT_FRAC)
    height_px = h_roi - surface_y

    # annotate on ROI
    vis = roi.copy()
    cv2.rectangle(vis, (0,0), (vis.shape[1]-1, vis.shape[0]-1), (255,255,255), 2)
    cv2.line(vis, (0, surface_y), (vis.shape[1]-1, surface_y), (255,255,255), 2)

    # show the band limits for sanity
    y_top = int(h_roi * SEARCH_TOP_FRAC)
    y_bot = int(h_roi * (1.0 - SEARCH_BOT_FRAC))
    cv2.line(vis, (0, y_top), (vis.shape[1]-1, y_top), (180,180,180), 1)
    cv2.line(vis, (0, y_bot), (vis.shape[1]-1, y_bot), (180,180,180), 1)

    ts = now_iso()
    append_log(ts, height_px, rejected)

    if args.save_image:
        os.makedirs(os.path.expanduser(args.image_dir), exist_ok=True)
        out = os.path.join(os.path.expanduser(args.image_dir), f"{args.prefix}_{ts.replace(':','-')}.jpg")
        cv2.imwrite(out, vis)

    print(f"{ts} height_px={height_px} rejected={rejected}")
    return 0

if __name__ == "__main__":
    raise SystemExit(main())
