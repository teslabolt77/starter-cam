#!/usr/bin/env python3
"""
starter_capture.py â€” Sourdough starter surface detector (lid-robust + stable exposure)

Fixes in this version:
- Uses YOUR camera's actual v4l2 control names:
    auto_exposure (menu), exposure_time_absolute (int),
    white_balance_automatic (bool), white_balance_temperature (int)
- Surface detection via vertical intensity transition (projection)
- Confidence is normalized (peak vs baseline), so thresholds make sense across lighting
- Hard ROI clamp to avoid lid/rim
- Debug ROI + overlay
"""

import argparse
import os
import time
import shutil
import subprocess
from dataclasses import dataclass
from typing import Optional, Tuple

import cv2
import numpy as np


# -------------------- DEFAULTS --------------------
DEFAULT_SEARCH_TOP_FRAC = 0.40
DEFAULT_SEARCH_BOT_FRAC = 0.80  # keep below lid/rim

ROW_SMOOTH_K = 21
GRAY_BLUR = 9

# Normalized confidence threshold (unitless). Start here; tweak if needed.
DEFAULT_MIN_CONF = 1.0

DEFAULT_DEBUG = True


# -------------------- UTIL --------------------
def ensure_dir(path: str) -> None:
    os.makedirs(path, exist_ok=True)

def now_stamp() -> str:
    return time.strftime("%Y%m%d_%H%M%S")

@dataclass
class DetectorState:
    prev_y: Optional[int] = None
    ema_y: Optional[float] = None


# -------------------- v4l2-ctl --------------------
def have_v4l2ctl() -> bool:
    return shutil.which("v4l2-ctl") is not None

def run_v4l2ctl(args_list) -> None:
    try:
        subprocess.run(["v4l2-ctl", *args_list],
                       check=False, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    except Exception:
        pass

def apply_camera_controls(device_index: int,
                          auto: Optional[str],
                          exposure: Optional[int],
                          gain: Optional[int],
                          brightness: Optional[int],
                          contrast: Optional[int],
                          sharpness: Optional[int],
                          wb_auto: Optional[str],
                          wb_temp: Optional[int],
                          af: Optional[str]) -> None:
    """
    Apply best-effort controls using names found in your v4l2 list-ctrls output.
    """
    if not have_v4l2ctl():
        return

    dev = f"/dev/video{device_index}"

    # Your camera:
    # auto_exposure: menu, value=3 (Aperture Priority Mode) currently
    # Common UVC: 1=Manual, 3=Aperture Priority (auto-ish)
    if auto is not None:
        if auto.lower() == "off":
            run_v4l2ctl(["-d", dev, "-c", "auto_exposure=1"])   # Manual mode
        else:
            run_v4l2ctl(["-d", dev, "-c", "auto_exposure=3"])   # Auto-ish

    # exposure_time_absolute becomes active only in manual mode
    if exposure is not None:
        run_v4l2ctl(["-d", dev, "-c", f"exposure_time_absolute={exposure}"])

    if gain is not None:
        run_v4l2ctl(["-d", dev, "-c", f"gain={gain}"])

    if brightness is not None:
        run_v4l2ctl(["-d", dev, "-c", f"brightness={brightness}"])

    if contrast is not None:
        run_v4l2ctl(["-d", dev, "-c", f"contrast={contrast}"])

    if sharpness is not None:
        run_v4l2ctl(["-d", dev, "-c", f"sharpness={sharpness}"])

    # White balance on your camera:
    # white_balance_automatic (bool)
    # white_balance_temperature (inactive unless auto is off)
    if wb_auto is not None:
        if wb_auto.lower() == "off":
            run_v4l2ctl(["-d", dev, "-c", "white_balance_automatic=0"])
        else:
            run_v4l2ctl(["-d", dev, "-c", "white_balance_automatic=1"])

    if wb_temp is not None:
        run_v4l2ctl(["-d", dev, "-c", f"white_balance_temperature={wb_temp}"])

    # Autofocus continuous control exists on your camera:
    # focus_automatic_continuous (bool)
    if af is not None:
        if af.lower() == "off":
            run_v4l2ctl(["-d", dev, "-c", "focus_automatic_continuous=0"])
        else:
            run_v4l2ctl(["-d", dev, "-c", "focus_automatic_continuous=1"])


# -------------------- DETECTION --------------------
def _odd(n: int) -> int:
    return n if (n % 2 == 1) else n + 1

def pick_surface_row_intensity(roi_bgr: np.ndarray) -> Tuple[int, float]:
    """
    Find surface by strongest downward intensity change.
    Returns (row_idx_rel, conf_norm).
    conf_norm is normalized peak prominence (unitless).
    """
    gray = cv2.cvtColor(roi_bgr, cv2.COLOR_BGR2GRAY)

    k = _odd(GRAY_BLUR)
    if k >= 3:
        gray = cv2.GaussianBlur(gray, (k, k), 0)

    row_means = np.mean(gray, axis=1)          # shape (H,)
    diff = row_means[:-1] - row_means[1:]      # shape (H-1,)

    sk = _odd(ROW_SMOOTH_K)
    if sk >= 3 and diff.shape[0] >= sk:
        diff = cv2.GaussianBlur(diff.reshape(-1, 1), (1, sk), 0).ravel()

    # Normalized confidence: how prominent is the best transition vs baseline?
    peak_idx = int(np.argmax(diff))
    peak_val = float(diff[peak_idx])

    baseline = float(np.median(diff))
    mad = float(np.median(np.abs(diff - baseline))) + 1e-6  # robust scale
    conf_norm = (peak_val - baseline) / (1.4826 * mad)      # ~robust z-score

    return peak_idx, conf_norm


# -------------------- CAPTURE --------------------
def open_camera(device: int, width: int, height: int) -> cv2.VideoCapture:
    cap = cv2.VideoCapture(device)
    if width > 0:
        cap.set(cv2.CAP_PROP_FRAME_WIDTH, width)
    if height > 0:
        cap.set(cv2.CAP_PROP_FRAME_HEIGHT, height)
    return cap


def main() -> int:
    ap = argparse.ArgumentParser()

    ap.add_argument("--device", type=int, default=0)
    ap.add_argument("--width", type=int, default=0)
    ap.add_argument("--height", type=int, default=0)

    ap.add_argument("--save-image", action="store_true")
    ap.add_argument("--image-dir", default="/home/pi/starter_cam/captures")
    ap.add_argument("--prefix", default="starter")

    ap.add_argument("--search-top-frac", type=float, default=DEFAULT_SEARCH_TOP_FRAC)
    ap.add_argument("--search-bot-frac", type=float, default=DEFAULT_SEARCH_BOT_FRAC)

    ap.add_argument("--min-conf", type=float, default=DEFAULT_MIN_CONF)

    ap.add_argument("--debug", action="store_true", default=DEFAULT_DEBUG)
    ap.add_argument("--no-debug", action="store_true")

    # Camera locks (match your v4l2 control names)
    ap.add_argument("--auto", choices=["on", "off"], default=None, help="auto_exposure on/off")
    ap.add_argument("--exposure", type=int, default=None, help="exposure_time_absolute (manual mode)")
    ap.add_argument("--gain", type=int, default=None, help="gain")
    ap.add_argument("--brightness", type=int, default=None, help="brightness")
    ap.add_argument("--contrast", type=int, default=None, help="contrast")
    ap.add_argument("--sharpness", type=int, default=None, help="sharpness")
    ap.add_argument("--wb-auto", choices=["on", "off"], default=None, help="white_balance_automatic on/off")
    ap.add_argument("--wb-temp", type=int, default=None, help="white_balance_temperature (when wb-auto off)")
    ap.add_argument("--af", choices=["on", "off"], default=None, help="focus_automatic_continuous on/off")

    args = ap.parse_args()
    debug = args.debug and (not args.no_debug)

    ensure_dir(args.image_dir)

    # Apply camera controls BEFORE capture
    apply_camera_controls(
        device_index=args.device,
        auto=args.auto,
        exposure=args.exposure,
        gain=args.gain,
        brightness=args.brightness,
        contrast=args.contrast,
        sharpness=args.sharpness,
        wb_auto=args.wb_auto,
        wb_temp=args.wb_temp,
        af=args.af,
    )

    cap = open_camera(args.device, args.width, args.height)
    if not cap.isOpened():
        print("ERROR: Could not open camera.")
        return 1

    ok, frame = cap.read()
    cap.release()
    if not ok or frame is None:
        print("ERROR: Could not read frame.")
        return 2

    H, W = frame.shape[:2]
    y1 = int(np.clip(H * args.search_top_frac, 0, H - 2))
    y2 = int(np.clip(H * args.search_bot_frac, y1 + 1, H - 1))
    roi = frame[y1:y2, :].copy()

    row_rel, conf = pick_surface_row_intensity(roi)
    rejected = conf < args.min_conf
    if rejected:
        row_rel = roi.shape[0] // 2

    y = y1 + row_rel

    # Save main capture
    if args.save_image:
        img_path = os.path.join(args.image_dir, f"{args.prefix}_{now_stamp()}.jpg")
        cv2.imwrite(img_path, frame)
        print(img_path)

    # Debug outputs
    if debug:
        roi_path = os.path.join(args.image_dir, f"{args.prefix}_roi_{now_stamp()}.jpg")
        cv2.imwrite(roi_path, roi)

        overlay = frame.copy()
        cv2.line(overlay, (0, y1), (W - 1, y1), (0, 255, 255), 1)
        cv2.line(overlay, (0, y2), (W - 1, y2), (0, 255, 255), 1)
        cv2.line(overlay, (0, y), (W - 1, y), (0, 255, 0), 2)

        label = f"surface_y={y} conf={conf:.2f} ROI[{y1}:{y2}]"
        if rejected:
            label += " REJECTED"
        cv2.putText(overlay, label, (10, 25), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 2)

        ov_path = os.path.join(args.image_dir, f"{args.prefix}_overlay_{now_stamp()}.jpg")
        cv2.imwrite(ov_path, overlay)

    print(f"SURFACE_Y {y} conf={conf:.2f} ROI[{y1}:{y2}]{' REJECTED' if rejected else ''}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
